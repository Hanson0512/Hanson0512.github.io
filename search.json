[{"title":"NSS工坊格","url":"/2025/11/29/NSSCTF%E5%B7%A5%E5%9D%8A%E6%A0%BC%E5%AF%86%E7%A0%81/","content":"NSSCTF工坊格密码\n\n1.\nfrom Crypto.Util.number import *p = getPrime(1024)f = getPrime(400)g = getPrime(512)r = getPrime(400)h = inverse(f, p) * g % pm = b'******'m = bytes_to_long(m)c = (r*h + m) % pprint(f'p = {p}')print(f'h = {h}')print(f'c = {c}')'''p = 170990541130074930801165526479429022133700799973347532191727614846803741888876816210632483231997413973919037199883422312436314365293577997262903161076615619596783971730864586404602951191341733308807254112018161897113881363794353050758324742415299277578203838160939521046655099610387485947145087271531951477031h = 19027613518333504891337723135627869008620752060390603647368919831595397216728378486716291001290575802095059192000315493444659485043387076261350378464749849058547797538347059869865169867814094180939070464336693973680444770599657132264558273692580535803622882040948521678860110391309880528478220088107038861065c = 75639016590286995205676932417759002029770539425113355588948888258962338419567264292295302442895077764630601149285564849867773180066274580635377957966186472159256462169691456995594496690536094824570820527164224000505303071962872595619159691416247971024761571538057932032549611221598273371855762399417419551483'''\n经典的ntru\n进行一个简单的推导：\nh=f^{-1}g\\ (mod\\ p)→hf\\equiv g\\ (mod\\ p)→g=hf-kp\n造格：\n(1h0p)\\left(\\begin{matrix}1&amp;h\\\\0&amp;p\\end{matrix}\\right)\n(​1​0​​​h​p​​)\n得到f，g\n然后得出cf\\equiv rg+mf\\ (mod\\ p)，根据数量大小，能够得出cf(modp)=rg+mf再modg即可轻松求解\n这边想给出一些其他的解法和我的一些困惑：\n首先对于c=rh+m\\ (mod\\ p)→m=c+kp-rh\n能够直接构造三维格进行处理：\n(24000c01p00−h)\\left(\\begin{matrix}2^{400}&amp;0&amp;c\\\\0&amp;1&amp;p\\\\0&amp;0&amp;-h\\end{matrix}\\right)\n​⎝​⎛​​​2​400​​​0​0​​​0​1​0​​​c​p​−h​​​⎠​⎞​​\n但是对于四维格的情况却无法得到想要的结果：\n(10021000h0102100000121000p000−21000c)\\left(\\begin{matrix}1&amp;0&amp;0&amp;2^{1000}h\\\\0&amp;1&amp;0&amp;2^{1000}\\\\0&amp;0&amp;1&amp;2^{1000}p\\\\0&amp;0&amp;0&amp;-2^{1000}c\\end{matrix}\\right)\n​⎝​⎜​⎜​⎛​​​1​0​0​0​​​0​1​0​0​​​0​0​1​0​​​2​1000​​h​2​1000​​​2​1000​​p​−2​1000​​c​​​⎠​⎟​⎟​⎞​​\n对于这个格将其左乘(r,m,-k,1)能够得到(r,m,-k,0)（理想情况下）但发现无法得到想要的m（即使对最后一列进行系数调整,使其满足hermite定理也无法得到）\n通过咨询DexterJie师傅学习到了一个重要的结论：造格的时候模数最好放在对角线上！\n于是对格进行调整：\n(10021000h01021000001−21000c00021000p)\\left(\\begin{matrix}1&amp;0&amp;0&amp;2^{1000}h\\\\0&amp;1&amp;0&amp;2^{1000}\\\\0&amp;0&amp;1&amp;-2^{1000}c\\\\0&amp;0&amp;0&amp;2^{1000}p\\end{matrix}\\right)\n​⎝​⎜​⎜​⎛​​​1​0​0​0​​​0​1​0​0​​​0​0​1​0​​​2​1000​​h​2​1000​​​−2​1000​​c​2​1000​​p​​​⎠​⎟​⎟​⎞​​\n这个时候对应的式子就是(r,m,1,-k)A=(r,m,1,0)由于系数不平衡，进行配平：\n(10021000h01021000002400−21000c00021000p)\\left(\\begin{matrix}1&amp;0&amp;0&amp;2^{1000}h\\\\0&amp;1&amp;0&amp;2^{1000}\\\\0&amp;0&amp;2^{400}&amp;-2^{1000}c\\\\0&amp;0&amp;0&amp;2^{1000}p\\end{matrix}\\right)\n​⎝​⎜​⎜​⎛​​​1​0​0​0​​​0​1​0​0​​​0​0​2​400​​​0​​​2​1000​​h​2​1000​​​−2​1000​​c​2​1000​​p​​​⎠​⎟​⎟​⎞​​\n于是就能够得到flag了\n这边做出来之后分析了一下，好像顿悟了一点，本来的格出来的小基向量中含有k，这是未知位数的，很可能会对规约结果造成影响；而调整格的构造后基向量中k就消失了，可以对明确的位数进行平衡，于是就能很好地解决了\n总结：\n造格的时候最好把模数放在对角线上\n当基向量中存在未知位数的k且求不出结果时，不妨试一试调整一下格的构造\n2.\nfrom Crypto.Util.number import *import randomfrom gmpy2 import *flag = bytes_to_long(b'******')flag = bin(flag)[2:]n = len(flag)a = [random.randint(1, 4**n)]s = a[0]for i in range(1, n):    a.append(random.randint(s+1, 4**(n+i)))    s += a[i]m = random.randint(a[-1] + 1, 2*a[-1])w = random.randint(1, m)assert gcd(w, m) == 1b = [w*i % m for i in a]c = 0for i in range(len(b)):    c = (c + b[i]*int(flag[i]))with open('output', 'w+') as f:    print(f'b = {b}', file=f)    print(f'c = {c}', file=f)\n这道题刚开始被引导到奇怪的方向了，实际上不需要管b具体的生成过程，主要关注这一段代码：\nfor i in range(len(b)):    c = (c + b[i]*int(flag[i]))\n这边将flag转为长整数后将其转换为二进制字符串，然后与b列表对应索引的值进行相乘并累加，实际上就是一个背包密码的考察\n构造以下格：\n\\left( \\right)\n\n用(m_0,m_1,……,m_n,1)乘这个矩阵即能得到小基(m_0,m_1,……,m_n,0)\nfrom Crypto.Util.number import *b = c = n = len(b)L = Matrix(ZZ,n+1,n+1)for i in range(n):    L[i,i] = 1    L[i,-1] = b[i]L[-1,-1] = -cres = L.LLL()for j in range(n+1):    M = res.row(j).list()    flag = True    for m in M:        if m!=0 and m!=1:            flag = False            break    if flag:        print(j)        print(M)        flag = ''.join(str(bit) for bit in M[:-1])        print(long_to_bytes(int(flag, 2)))\n需要注意的是，恢复flag的时候需要将得到的小基向量的最后一列值去掉\n3.\nfrom Crypto.Util.number import *import randomflag = b'******'m = bytes_to_long(flag)a = getPrime(1024)b = getPrime(1536)p = getPrime(512)q = getPrime(512)r = random.randint(2**14, 2**15)assert ((p-r) * a + q) % b &lt; 50c = pow(m, 65537, p*q)print(f'c = {c}')print(f'a = {a}')print(f'b = {b}')\n4.\nfrom Crypto.Util.number import *from gmpy2 import *flag = b'******'flag = bytes_to_long(flag)p = getPrime(1024)r = getPrime(175)a = inverse(r, p)a = (a*flag) % pprint(f'a = {a}')print(f'p = {p}')\n这道题比较简单，进行简单推导：\na=am\\ (mod\\ p)→ar\\equiv m\\ (mod\\ p)→m=ar-kp\n于是构造格：\n(1a0p)\\left( \\begin{matrix}  1 &amp; a\\\\0&amp;p\\end{matrix}\\right)\n(​1​0​​​a​p​​)\n预期的小基向量是(r,m)，此处大小设置合理，满足hermite定理\nfrom Crypto.Util.number import *a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591ge=Matrix(ZZ,[[1,a],[0,p]])tg=ge.LLL()[0].list()tg=[abs(i) for i in tg]print(long_to_bytes(tg[1]))\n5.\nfrom Crypto.Util.number import *from gmpy2 import *flag = b'******'m = bytes_to_long(flag)assert m.bit_length() == 351p = getPrime(1024)b = getPrime(1024)c = getPrime(400)a = (b*m + c) % pprint(f'a = {a}')print(f'b = {b}')print(f'p = {p}')'''a = 92716521851427599147343828266552451834533034815416003395170301819889384044273026852184291232938197215198124164263722270347104189412921224361134013717269051168246275213624264313794650441268405062046423740836145678559969020294978939553573428334198212792931759368218132978344815862506799287082760307048309578592b = 155530728639099361922541063573602659584927544589739208888076194504495146661257751801481540924821292656785953391450218803112838556107960071792826902126414012831375547340056667753587086997958522683688746248661290255381342148052513971774612583235459904652002495564523557637169529882928308821019659377248151898663p = 100910862834849216140965884888425432690937357792742349763319405418823395997406883138893618605587754336982681610768197845792843123785451070312818388494074168909379627989079148880913190854232917854414913847526564520719350308494462584771237445179797367179905414074344416047541423116739621805238556845903951985783'''\n推导：a=bm+c-kp→c=a-bm+kp\n根据题目给出的数的大小，我们尽量将m，c这类小数字放在规约后的基向量中，因此构造格：\n(10a01−b00p)\\left(\\begin{matrix}1&amp;0&amp;a\\\\0&amp;1&amp;-b\\\\0&amp;0&amp;p\\end{matrix}\\right)\n​⎝​⎛​​​1​0​0​​​0​1​0​​​a​−b​p​​​⎠​⎞​​\n这样得到的基向量为(1,m,c)显然维度不均衡，进行配平：\n(24000a01−b00p)\\left(\\begin{matrix}2^{400}&amp;0&amp;a\\\\0&amp;1&amp;-b\\\\0&amp;0&amp;p\\end{matrix}\\right)\n​⎝​⎛​​​2​400​​​0​0​​​0​1​0​​​a​−b​p​​​⎠​⎞​​\nfrom Crypto.Util.number import *a = 92716521851427599147343828266552451834533034815416003395170301819889384044273026852184291232938197215198124164263722270347104189412921224361134013717269051168246275213624264313794650441268405062046423740836145678559969020294978939553573428334198212792931759368218132978344815862506799287082760307048309578592b = 155530728639099361922541063573602659584927544589739208888076194504495146661257751801481540924821292656785953391450218803112838556107960071792826902126414012831375547340056667753587086997958522683688746248661290255381342148052513971774612583235459904652002495564523557637169529882928308821019659377248151898663p = 100910862834849216140965884888425432690937357792742349763319405418823395997406883138893618605587754336982681610768197845792843123785451070312818388494074168909379627989079148880913190854232917854414913847526564520719350308494462584771237445179797367179905414074344416047541423116739621805238556845903951985783ge=Matrix(ZZ,[[2**400,0,a],[0,1,-b],[0,0,p]])tg=ge.LLL()[0].list()print(long_to_bytes(abs(tg[1])))\n6.\nfrom Crypto.Util.number import *flag = b'******'flag = bytes_to_long(flag)d = getPrime(400)for i in range(4):    p = getPrime(512)    q = getPrime(512)    n = p * q    e = inverse(d, (p-1)*(q-1))    c = pow(flag, e, n)    print(f'e{i} =', e)    print(f'n{i} =', n)    print(f'c{i} =', c)\n给了四组以相同私钥生成的公钥，每一组大概能表示成下面的形式：\ne_id-k_in_i=1+k_is_i(其中s_i=1-p_i-q_i)\n\nIJCSI-9-2-1-311-314.pdf\n检索到论文（使用关键词lattice common private)\n根据论文构造格即可：\nfrom Crypto.Util.number import *import gmpy2print(max([n0,n1,n2,n3]))M=int(gmpy2.iroot(n0,2)[0])ge=Matrix(ZZ,[[M,e0,e1,e2,e3],[0,-n0,0,0,0],[0,0,-n1,0,0],[0,0,0,-n2,0],[0,0,0,0,-n3]])tg=ge.LLL()[0].list()[0]d=abs(tg)//Mm=pow(c0,d,n0)print(m)print(long_to_bytes(int(m)))\n7.\nfrom Crypto.Util.number import *flag = b'******'flag = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p * qc = pow(flag, 65537, n)print(f'n =', n)print(f'c =', c)for i in range(2):    d = getPrime(350)    e = inverse(d, (p-1)*(q-1))    print(f'e{i} =', e)\n这是一道扩展维纳攻击的题目\n利用脚本即可\nfrom Crypto.Util.number import *def wienerAttack2(N, e1, e2):    a = 5/14    D = diagonal_matrix(ZZ, [N, int(N^(1/2)), int(N^(1+a)), 1])    M = matrix(ZZ, [[1, -N, 0, N^2], [0, e1, -e1, -e1*N], [0, 0, e2, -e2*N], [0, 0, 0, e1*e2]])*D    L = M.LLL()    B = vector(ZZ, L[0])    A = B * M^(-1)    phi = int(A[1]/A[0]*e1)    d1 = inverse_mod(e1, phi)    d2 = inverse_mod(e2, phi)    p = var('p', domain=ZZ)    roots = solve(p ** 2 + (phi - N - 1) * p + N, p)    if len(roots) == 2:        # possible p, q        p, q = roots        if p * q == N:            return p, q, d1, d2    raise ValueError('Could not factor N!')p, q, d1, d2 = wienerAttack2(n, e0, e1)print(p)phi=(p-1)*(q-1)print(phi)d=inverse(65537,int(phi))print(d)m=pow(c,d,n)print(m)print(long_to_bytes(2806865643354785578450609045733131286744118434356323182772206641287491355913070780758914698246985892323709))\n8.\nfrom Crypto.Util.number import *flag = b'******'m = bytes_to_long(flag)p = getPrime(512)s = [getPrime(32) for i in range(3)]a = [getPrime(512) for i in range(3)]c = (a[0]*s[0]**2*s[1]**2 + a[1]*s[0]*s[2]**2 + a[2]*s[1]*s[2]) % pflag = m*s[0]*s[1]*s[2]print(f'c = {c}')print(f'flag = {flag}')print(f'a = {a}')print(f'p = {p}')\nc=a0s02s12+a1s0s22+a2s1s2 (mod p)c=a_0s_0^2s_1^2+a_1s_0s_2^2+a_2s_1s_2\\ (mod\\ p)c=a​0​​s​0​2​​s​1​2​​+a​1​​s​0​​s​2​2​​+a​2​​s​1​​s​2​​ (mod p)\n预期的解法应该是利用格相关的操作求出s0s1s2后得到m，（虽然非预期可以直接分解flag啊喂）\n按照预期打一下，造了一个非官方解的格：\n(100a00010a10001a20000−p0000c1)\\left(\\begin{matrix}1&amp;0&amp;0&amp;a_0&amp;0\\\\0&amp;1&amp;0&amp;a_1&amp;0\\\\0&amp;0&amp;1&amp;a_2&amp;0\\\\0&amp;0&amp;0&amp;-p&amp;0\\\\0&amp;0&amp;0&amp;c&amp;1\\end{matrix}\\right)\n​⎝​⎜​⎜​⎜​⎜​⎛​​​1​0​0​0​0​​​0​1​0​0​0​​​0​0​1​0​0​​​a​0​​​a​1​​​a​2​​​−p​c​​​0​0​0​0​1​​​⎠​⎟​⎟​⎟​⎟​⎞​​\n使用(s02s12,s0s22,s1s2,−k,1)(s_0^2s_1^2,s_0s_2^2,s_1s_2,-k,1)(s​0​2​​s​1​2​​,s​0​​s​2​2​​,s​1​​s​2​​,−k,1)左乘矩阵可以得到(s02s12,s0s22,s1s2,0,1)(s_0^2s_1^2,s_0s_2^2,s_1s_2,0,1)(s​0​2​​s​1​2​​,s​0​​s​2​2​​,s​1​​s​2​​,0,1)\n很明显基向量的维度不匹配，为了满足LLL的特性，进行配平：\n(100a0002320a1000264a20000−p0000c2128)\\left(\\begin{matrix}1&amp;0&amp;0&amp;a_0&amp;0\\\\0&amp;2^{32}&amp;0&amp;a_1&amp;0\\\\0&amp;0&amp;2^{64}&amp;a_2&amp;0\\\\0&amp;0&amp;0&amp;-p&amp;0\\\\0&amp;0&amp;0&amp;c&amp;2^{128}\\end{matrix}\\right)\n​⎝​⎜​⎜​⎜​⎜​⎛​​​1​0​0​0​0​​​0​2​32​​​0​0​0​​​0​0​2​64​​​0​0​​​a​0​​​a​1​​​a​2​​​−p​c​​​0​0​0​0​2​128​​​​​⎠​⎟​⎟​⎟​⎟​⎞​​\nfrom Crypto.Util.number import *import gmpy2ge=Matrix(ZZ,5,5)for i in range(3):    ge[i,i]=2**(32*i)    ge[i,-2]=a[i]ge[-1,-1]=2**128ge[-2,-2]=-pge[-1,-2]=ctg=ge.LLL()for row in tg:    if(abs(row[-1]))==2**128:        ls=row.list()        print(ls)        breakls=[abs(i) for i in ls]s=1for i in ls[:3]:    s*=ip=gmpy2.iroot(s//(2**96),3)[0]print(p)flag=flag//pprint(long_to_bytes(flag))\n","categories":["Lattice"]},{"title":"RSA考点之coppersmith","url":"/2025/01/19/RSA%E8%80%83%E7%82%B9%E4%B9%8Bcoppersmith/","content":"Coppersmith攻击\n\n一、引言\n近期参加的各类CTF比赛中，常见到coppersmith攻击的考点，于是在此做一个简单的学习与总结，后续若还有新的coppersmith的考点，会在文章中作出补充。\n二、Coppersmith攻击原理\n真正能够用好一个方法，一定要搞清楚这个方法背后的本质原理，于是我在网上搜集资料，找到了Coppersmith攻击的原理。\n对于\nf(x)=a1xm+a2xm−1+⋯+am+1f(x)=a_1x^m+a_2x^{m-1}+\\cdots+a_m+1\nf(x)=a​1​​x​m​​+a​2​​x​m−1​​+⋯+a​m​​+1\n,要找到这个多项式在mod(N)mod(N)mod(N)意义下的根，在不限制的条件下这是一个很困难的问题。\n因为f(x)f(x)f(x)可以特别大只需要是NNN的倍数就可以\nmod(N)mod(N)mod(N)这一步带来很多困难.\n首先考虑一个特殊情况如果f(x)f(x)f(x)就等于0那么可以用牛顿迭代法求出来但是牛顿迭代法遇到mod(N)mod(N)mod(N)就失灵了.\n怎么办呢？没有条件就创造条件！\n大概的思路是如果xxx足够小使得∣f(x)∣\\vert f(x)\\vert∣f(x)∣|&lt;N&lt;N&lt;N那么f(x)==0f(x)==0f(x)==0\n这时候就满足了使用牛顿迭代法的条件\n那么现在问题集中在怎么证明∣f(x)∣\\vert f(x)\\vert∣f(x)∣|&lt;N&lt;N&lt;N.答案是：无法证明！因为没有限制aia_ia​i​​的大小\nCoppersmith想出了一个办法：能不能找一个系数的多项式g(x)g(x)g(x)当x=0x=0x=0时f(x)=0f(x)=0f(x)=0\n也就是说希望找到一个系数的多项式系数小到能够满足牛顿迭代法的要求那么问题就解决了，就差把x求出来。\nCoppersmith利用如下操作先得到一系列h(x)：hij(x)=xi∗fj(x)h_{ij}(x)=x^i*f^j(x)h​ij​​(x)=x​i​​∗f​j​​(x)\n再将一系列的h(x)经过线性组合得到g(x):g(x)=\\sum c_{ij}*h_{ij}(x)+d_{ij}\n为了让g(x)g(x)g(x)的系数尽量小就要用到LLL格基规约算法（关于LLL格基规约算法将在下一个博客中给出学习介绍）\n三、Coppersmith攻击在CTF比赛中的运用\n在CTF比赛中，使用Coppersmith攻击的主要原理是根据以下公式完成的：\nc=(m+t)e(modN)c=(m+t)^e (mod N)c=(m+t)​e​​(modN)\n这里只需要将t看成上述的x，即可把这个公式转换为求解一个有关t的多项式的根，其中，t要求不能太大，否则无法使用Coppersmith攻击原理解决\n具体来说，我们一般会在sagemath中利用smallrootssmall rootssmallroots函数来解决\nsmall_roots()是SageMath中一个运用了coppersmith定理的函数。它只能解有限域内的方程。\nsmall_roots(X = ,beta = ) 有两个参数\nX代表所需要求解根的上限；虽然是根的上限，并不是说上限越高越好，当上限超过某个值的时候就会计算失效，即使已知二进制位数满足条件，也无法用此函数求得结果；所以一般来说X取在给定情况下的最大求解上限\n那么下面，我们给出几个题目来理解一下Coppersmith攻击的运用吧\n1、极客：highlow\n先看题目：\nfrom Crypto.Util.number import *e = 65537p = getPrime(1024)q = getPrime(1024)n = p * qpxor = p ^ (bytes_to_long(flag)&lt;&lt;400)assert len(flag)== 44m = bytes_to_long(flag)c = pow(m, e, n)print(&#x27;c =&#x27;,c)print(&#x27;n =&#x27;,n)print(&#x27;pxor =&#x27;,pxor)&#x27;&#x27;&#x27;c = 11017336122691034053241992293963114590816319844384287448629663672049205892828600396465505710922907685545939978376321927394655458727494361852952898280905220963163625482295222856129164172619564344634365520328815972232825639292605311741655988427166811406091329613627961070231457035303298793651546412496975662225857123805867756651901374507447803198638466304862480202099076813471571495380132563252630789218173007275890600746758285415274434393381125742526014986039652677605642226576741424053749512280825231217420239089105794080707322357602941046822659335487420672699022969372037662958497832065752272061853723653365171768556n = 14091206320622523674847720139761543154822190879035380245424481267482550932229611965964424965958386255076593911062804299275581742665134207390532802109700225140999812698020838683697375891035625255222001884477214361835101442288725383073334392995186053867261497679234362794914108033574681292656522807928680812726462195077833184018122369579002715900477290345396065912536529290811962117814900448319776590712946259540382461632468634827959957286905806432005632864663985014872365672653476822833921870071851313424903481282350342304819149894610089804321405589433980650340610521659031234826823369114800150883988613877877881069579pxor = 124229245244085791439650934438639686782423445183921252684721764061493908790073948877623812930339081158169421854801552819088679937157357924845248082716160727839419054107753000815066526032809275137495740454967765165248115412626716101315676902716808647904092798908601183908297141420793614426863816161203796966951&#x27;&#x27;&#x27;\n44∗8+400=75244*8+400=75244∗8+400=752\n1024-752=272\n所以p高272已知\nphigh =(pxor>>752)","categories":["RSA"]},{"title":"Hello World","url":"/2024/11/16/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n"},{"title":"测试文章","url":"/2024/11/16/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","content":"这是一篇测试文章\n\n \n∑i=1nM=0\\sum_{i=1}^n M=0∑​i=1​n​​M=0\n","categories":["Python"]}]